.PHONY: help start stop restart logs clean setup-keycloak test-admin test-user test-denied

help: ## Show this help
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  \033[36m%-15s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST)

start: ## Start all services
	@echo "üöÄ Starting Zero Trust Architecture PoC..."
	@docker-compose up -d
	@echo "‚è≥ Waiting for services to be healthy..."
	@sleep 10
	@echo "‚úÖ Services started!"
	@echo ""
	@echo "üìã Access Points:"
	@echo "  Keycloak:       http://localhost:8180 (admin/admin)"
	@echo "  Go Service:     http://localhost:9001"
	@echo "  Python Service: http://localhost:9002"
	@echo "  C# Service:     http://localhost:9003"
	@echo "  OPA:            http://localhost:8181"
	@echo ""
	@echo "‚öôÔ∏è  Run 'make setup-keycloak' to configure Keycloak realm and users"

stop: ## Stop all services
	@docker-compose down

restart: stop start ## Restart all services

logs: ## Show logs
	@docker-compose logs -f

clean: ## Stop and remove everything
	@docker-compose down -v
	@docker system prune -f

setup-keycloak: ## Configure Keycloak (realm, users, roles)
	@echo "‚öôÔ∏è  Configuring Keycloak..."
	@bash scripts/setup-keycloak.sh
	@echo "‚úÖ Keycloak configured!"

test-admin: ## Test with admin token (should access everything)
	@echo "üß™ Testing with admin user..."
	@bash scripts/test-access.sh admin

test-user: ## Test with regular user (GET only)
	@echo "üß™ Testing with regular user..."
	@bash scripts/test-access.sh user

test-denied: ## Test denied access scenarios
	@echo "üß™ Testing access denial..."
	@bash scripts/test-access.sh denied
static_resources:
  listeners:
    - name: listener_0
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 8000
      filter_chains:
        - filters:
            - name: envoy.filters.network.http_connection_manager
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
                stat_prefix: ingress_http
                access_log:
                  - name: envoy.access_loggers.stdout
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.access_loggers.stream.v3.StdoutAccessLog
                route_config:
                  name: local_route
                  virtual_hosts:
                    - name: backend
                      domains: ["*"]
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: go_service
                http_filters:
                  # Step 1: Validate JWT from Keycloak
                  - name: envoy.filters.http.jwt_authn
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication
                      providers:
                        keycloak:
                          issuer: "http://localhost:8180/realms/demo"
                          audiences:
                            - "account"
                          remote_jwks:
                            http_uri:
                              uri: "http://keycloak:8180/realms/demo/protocol/openid-connect/certs"
                              cluster: keycloak_jwks
                              timeout: 5s
                            cache_duration:
                              seconds: 300
                          forward: true
                          payload_in_metadata: "jwt_payload"
                      rules:
                        - match:
                            prefix: "/health"
                        - match:
                            prefix: "/"
                          requires:
                            provider_name: "keycloak"

                  # Step 2: External Authorization via OPA
                  - name: envoy.filters.http.ext_authz
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
                      transport_api_version: V3
                      failure_mode_allow: false
                      grpc_service:
                        envoy_grpc:
                          cluster_name: opa_cluster
                        timeout: 1s
                      metadata_context_namespaces:
                        - envoy.filters.http.jwt_authn

                  # Step 3: Router (forward to backend)
                  - name: envoy.filters.http.router
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router

  clusters:
    # Backend service
    - name: go_service
      type: STRICT_DNS
      lb_policy: ROUND_ROBIN
      load_assignment:
        cluster_name: go_service
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: go-service
                      port_value: 8080

    # OPA cluster (gRPC)
    - name: opa_cluster
      type: STRICT_DNS
      typed_extension_protocol_options:
        envoy.extensions.upstreams.http.v3.HttpProtocolOptions:
          "@type": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions
          explicit_http_config:
            http2_protocol_options: {}
      load_assignment:
        cluster_name: opa_cluster
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: opa
                      port_value: 9191

    # Keycloak JWKS
    - name: keycloak_jwks
      type: STRICT_DNS
      connect_timeout: 5s
      lb_policy: ROUND_ROBIN
      load_assignment:
        cluster_name: keycloak_jwks
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: keycloak
                      port_value: 8080
static_resources:
  listeners:
    - name: listener_0
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 8000
      filter_chains:
        - filters:
            - name: envoy.filters.network.http_connection_manager
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
                stat_prefix: ingress_http
                access_log:
                  - name: envoy.access_loggers.stdout
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.access_loggers.stream.v3.StdoutAccessLog
                route_config:
                  name: local_route
                  virtual_hosts:
                    - name: backend
                      domains: ["*"]
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: python_service
                http_filters:
                  # Step 1: Validate JWT from Keycloak
                  - name: envoy.filters.http.jwt_authn
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication
                      providers:
                        keycloak:
                          issuer: "http://localhost:8180/realms/demo"
                          audiences:
                            - "account"
                          remote_jwks:
                            http_uri:
                              uri: "http://keycloak:8180/realms/demo/protocol/openid-connect/certs"
                              cluster: keycloak_jwks
                              timeout: 5s
                            cache_duration:
                              seconds: 300
                          forward: true
                          payload_in_metadata: "jwt_payload"
                      rules:
                        - match:
                            prefix: "/health"
                        - match:
                            prefix: "/"
                          requires:
                            provider_name: "keycloak"

                  # Step 2: External Authorization via OPA
                  - name: envoy.filters.http.ext_authz
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
                      transport_api_version: V3
                      failure_mode_allow: false
                      grpc_service:
                        envoy_grpc:
                          cluster_name: opa_cluster
                        timeout: 1s
                      metadata_context_namespaces:
                        - envoy.filters.http.jwt_authn

                  # Step 3: Router (forward to backend)
                  - name: envoy.filters.http.router
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router

  clusters:
    # Backend service
    - name: python_service
      type: STRICT_DNS
      lb_policy: ROUND_ROBIN
      load_assignment:
        cluster_name: python_service
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: python-service
                      port_value: 8080

    # OPA cluster (gRPC)
    - name: opa_cluster
      type: STRICT_DNS
      typed_extension_protocol_options:
        envoy.extensions.upstreams.http.v3.HttpProtocolOptions:
          "@type": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions
          explicit_http_config:
            http2_protocol_options: {}
      load_assignment:
        cluster_name: opa_cluster
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: opa
                      port_value: 9191

    # Keycloak JWKS
    - name: keycloak_jwks
      type: STRICT_DNS
      connect_timeout: 5s
      lb_policy: ROUND_ROBIN
      load_assignment:
        cluster_name: keycloak_jwks
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: keycloak
                      port_value: 8080
static_resources:
  listeners:
    - name: listener_0
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 8000
      filter_chains:
        - filters:
            - name: envoy.filters.network.http_connection_manager
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
                stat_prefix: ingress_http
                access_log:
                  - name: envoy.access_loggers.stdout
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.access_loggers.stream.v3.StdoutAccessLog
                route_config:
                  name: local_route
                  virtual_hosts:
                    - name: backend
                      domains: ["*"]
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: csharp_service
                http_filters:
                  # Step 1: Validate JWT from Keycloak
                  - name: envoy.filters.http.jwt_authn
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication
                      providers:
                        keycloak:
                          issuer: "http://localhost:8180/realms/demo"
                          audiences:
                            - "account"
                          remote_jwks:
                            http_uri:
                              uri: "http://keycloak:8180/realms/demo/protocol/openid-connect/certs"
                              cluster: keycloak_jwks
                              timeout: 5s
                            cache_duration:
                              seconds: 300
                          forward: true
                          payload_in_metadata: "jwt_payload"
                      rules:
                        - match:
                            prefix: "/health"
                        - match:
                            prefix: "/"
                          requires:
                            provider_name: "keycloak"

                  # Step 2: External Authorization via OPA
                  # Step 2: External Authorization via OPA
                  - name: envoy.filters.http.ext_authz
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
                      transport_api_version: V3
                      failure_mode_allow: false
                      grpc_service:
                        envoy_grpc:
                          cluster_name: opa_cluster
                        timeout: 1s
                      metadata_context_namespaces:
                        - envoy.filters.http.jwt_authn

                  # Step 3: Router (forward to backend)
                  - name: envoy.filters.http.router
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router

  clusters:
    # Backend service
    - name: csharp_service
      type: STRICT_DNS
      lb_policy: ROUND_ROBIN
      load_assignment:
        cluster_name: csharp_service
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: csharp-service
                      port_value: 8080

    # OPA cluster (gRPC)
    - name: opa_cluster
      type: STRICT_DNS
      typed_extension_protocol_options:
        envoy.extensions.upstreams.http.v3.HttpProtocolOptions:
          "@type": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions
          explicit_http_config:
            http2_protocol_options: {}
      load_assignment:
        cluster_name: opa_cluster
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: opa
                      port_value: 9191

    # Keycloak JWKS
    - name: keycloak_jwks
      type: STRICT_DNS
      connect_timeout: 5s
      lb_policy: ROUND_ROBIN
      load_assignment:
        cluster_name: keycloak_jwks
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: keycloak
                      port_value: 8080
# Zero Trust Architecture PoC

**Production-grade Zero Trust implementation** with Envoy sidecars, Keycloak JWT authentication, and OPA policy-based authorization.

## üéØ What This Demonstrates

‚úÖ **Envoy sidecar pattern** - Every service gets JWT validation + policy enforcement
‚úÖ **Keycloak authentication** - Centralized identity and JWT token issuance  
‚úÖ **OPA authorization** - Fine-grained ABAC policies separate from service code
‚úÖ **Zero Trust principles** - Never trust, always verify, enforce least privilege
‚úÖ **Service mesh lite** - No Kubernetes required for PoC

## üèóÔ∏è Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         CLIENT                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
                       ‚îÇ 1. Request + JWT Token
                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    ENVOY SIDECAR                            ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  Step 1: JWT Validation (Keycloak JWKS)              ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚úì Valid signature?                                   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚úì Not expired?                                       ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚úì Correct issuer?                                    ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                       ‚îÇ                                      ‚îÇ
‚îÇ                       ‚îÇ 2. Extract JWT claims                ‚îÇ
‚îÇ                       ‚ñº                                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  Step 2: External Authorization (OPA)                ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Send: JWT claims + HTTP method + path             ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ OPA evaluates ABAC policy                         ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Returns: allow/deny decision                      ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                       ‚îÇ                                      ‚îÇ
‚îÇ                       ‚îÇ 3. Forward if allowed                ‚îÇ
‚îÇ                       ‚ñº                                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  BACKEND SERVICE                            ‚îÇ
‚îÇ  ‚Ä¢ Go / Python / C# service                                 ‚îÇ
‚îÇ  ‚Ä¢ NO security code required                                ‚îÇ
‚îÇ  ‚Ä¢ Receives only authorized requests                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üöÄ Quick Start

```bash
# 1. Start all services
make start

# 2. Configure Keycloak (create realm, users, roles)
make setup-keycloak

# 3. Test admin access (can do everything)
make test-admin

# 4. Test user access (GET only)
make test-user

# 5. Test denied access
make test-denied
```

## üì¶ Components

### Services
- **Go Service** (port 9001) - Minimal HTTP server
- **Python Service** (port 9002) - FastAPI application
- **C# Service** (port 9003) - ASP.NET Core app

### Infrastructure
- **Keycloak** (port 8180) - Identity provider and JWT issuer
- **OPA** (port 8181) - Policy decision point
- **Envoy Proxies** - One sidecar per service

## üîê Security Flow

### 1. Authentication (Keycloak)
```bash
# Get JWT token
TOKEN=$(curl -s -X POST http://localhost:8180/realms/demo/protocol/openid-connect/token \
  -d "client_id=account" \
  -d "username=alice" \
  -d "password=password" \
  -d "grant_type=password" | jq -r '.access_token')

# Use token
curl -H "Authorization: Bearer $TOKEN" http://localhost:9001/api/data
```

### 2. Authorization (OPA Policies)

**Policy:** `opa/policies/authz.rego`

```rego
# Admins can access everything
allow {
    jwt_payload.realm_access.roles[_] == "admin"
}

# Users can only GET
allow {
    jwt_payload.realm_access.roles[_] == "user"
    http_request.method == "GET"
}

# Health endpoints always accessible
allow {
    http_request.path == "/health"
}
```

## üß™ Testing Scenarios

### Admin User (alice)
```bash
make test-admin
```
‚úÖ Can access all endpoints  
‚úÖ Can use all HTTP methods (GET, POST, PUT, DELETE)  
‚úÖ Can access `/admin/*` endpoints

### Regular User (bob)
```bash
make test-user
```
‚úÖ Can GET public and API endpoints  
‚ùå Cannot POST/PUT/DELETE  
‚ùå Cannot access `/admin/*` endpoints

### No Authentication
```bash
make test-denied
```
‚ùå All endpoints blocked (except `/health`)  
‚úÖ Health checks work without auth

## üìã Available Endpoints

| Endpoint | Admin | User | Anonymous |
|----------|-------|------|-----------|
| `GET /` | ‚úÖ | ‚úÖ | ‚ùå |
| `GET /health` | ‚úÖ | ‚úÖ | ‚úÖ |
| `GET /api/data` | ‚úÖ | ‚úÖ | ‚ùå |
| `POST /api/data` | ‚úÖ | ‚ùå | ‚ùå |
| `GET /admin/users` | ‚úÖ | ‚ùå | ‚ùå |

## üîß Configuration

### Envoy (JWT Validation)
File: `envoy/go-service-envoy.yaml`

```yaml
jwt_authn:
  providers:
    keycloak:
      issuer: "http://keycloak:8180/realms/demo"
      remote_jwks:
        uri: "http://keycloak:8180/realms/demo/protocol/openid-connect/certs"
      forward: true  # Forward JWT to OPA
```

### Envoy (External Authorization)
```yaml
ext_authz:
  grpc_service:
    envoy_grpc:
      cluster_name: opa_cluster
```

### OPA Policy
All policies in: `opa/policies/`

Modify `authz.rego` to add custom rules:
```rego
# Example: Allow service accounts
allow {
    jwt_payload.resource_access.account.roles[_] == "service"
    startswith(http_request.path, "/api/")
}
```

## üéì Key Learnings

### Why Envoy Sidecar?
‚úÖ **Zero service code changes** - Security enforced at proxy layer  
‚úÖ **Polyglot support** - Same pattern for Go/Python/C#/any language  
‚úÖ **Centralized policy** - Change OPA policies without redeploying services  
‚úÖ **Defense in depth** - Multiple validation layers

### Why OPA?
‚úÖ **Policy as code** - Version control your authorization logic  
‚úÖ **Testing** - Unit test policies before deployment  
‚úÖ **Auditability** - Clear reasoning for allow/deny decisions  
‚úÖ **Flexibility** - Complex ABAC rules with JSON/JWT claims

### Production Considerations

**For Kubernetes:**
1. Use **Istio** or **Linkerd** for automatic sidecar injection
2. Deploy **EnvoyFilter** CRDs instead of manual config
3. Use **Styra DAS** or OPA Gatekeeper for policy management
4. Enable **mTLS** between services
5. Add **distributed tracing** (already in your OTel PoC!)

**For This PoC ‚Üí Production Migration:**
- Replace docker-compose with Kubernetes manifests
- Use Helm charts for deployment
- Add persistent storage for Keycloak
- Configure TLS certificates
- Set up monitoring (your OTel stack!)
- Implement policy versioning

## üõ†Ô∏è Development

### Add a New Service

1. Create service directory in `services/`
2. Copy and modify Envoy config
3. Add to `docker-compose.yml`
4. Update OPA policies if needed

### Modify Policies

1. Edit `opa/policies/authz.rego`
2. Test with: `docker restart opa`
3. Verify with: `make test-admin` or `make test-user`

### Debug

```bash
# View Envoy logs
docker logs go-service-envoy -f

# View OPA logs (shows policy decisions)
docker logs opa -f

# View Keycloak logs
docker logs keycloak -f

# Check JWT validation
curl -H "Authorization: Bearer $TOKEN" http://localhost:9001/api/data -v
```

## üìä Observability Integration

**Combine with your OpenTelemetry PoC!**

Add to Envoy config:
```yaml
tracing:
  provider:
    name: envoy.tracers.opentelemetry
    typed_config:
      "@type": type.googleapis.com/envoy.config.trace.v3.OpenTelemetryConfig
      grpc_service:
        envoy_grpc:
          cluster_name: otel-collector
```

Then you get:
- **Traces:** See JWT validation + OPA decision time
- **Metrics:** Track authorization denials, latencies
- **Logs:** Correlate security events with service logs

## üîó Resources

- [Envoy JWT Authentication](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/jwt_authn_filter)
- [Envoy External Authorization](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/ext_authz_filter)
- [OPA Documentation](https://www.openpolicyagent.org/docs/latest/)
- [Keycloak Documentation](https://www.keycloak.org/documentation)
- [Zero Trust Architecture (NIST)](https://csrc.nist.gov/publications/detail/sp/800-207/final)

## üéØ Next Steps

1. ‚úÖ **Run the PoC** - `make start && make setup-keycloak`
2. ‚úÖ **Understand the flow** - Read Envoy configs and OPA policies
3. ‚úÖ **Test different scenarios** - Try all three test commands
4. üöÄ **Deploy to Kubernetes** - Migrate to Istio + EnvoyFilter
5. üîó **Add to OTel PoC** - Combine ZTA with observability

## üí° Pro Tips

- **JWT Debugging:** Use [jwt.io](https://jwt.io) to decode tokens
- **OPA Testing:** Use `opa test` command for policy unit tests
- **Envoy Admin:** Access `http://localhost:9901` for Envoy admin interface
- **Keycloak Console:** Full UI at `http://localhost:8180` (admin/admin)

## ü§ù Contributing

This is a reference PoC. Adapt it to your needs:
- Add more services
- Implement custom OPA policies
- Integrate with your existing identity provider
- Deploy to your Kubernetes cluster

---

**Built with:**
- Envoy 1.29.1
- Keycloak 23.0.4
- OPA 0.60.0
- Go 1.21, Python 3.11, .NET 8.0
*.swp
*.swo
*~
.DS_Store
.env
.vscode/
.idea/
__pycache__/
*.pyc
bin/
obj/
#!/bin/bash
set -e

KEYCLOAK_URL="http://localhost:8180"
GO_SERVICE="http://localhost:9001"
PYTHON_SERVICE="http://localhost:9002"
CSHARP_SERVICE="http://localhost:9003"

get_token() {
    local username=$1
    local password=$2
    curl -s -X POST "$KEYCLOAK_URL/realms/demo/protocol/openid-connect/token" \
      -d "client_id=demo-client" \
      -d "username=$username" \
      -d "password=$password" \
      -d "grant_type=password" | jq -r '.access_token'
}

test_endpoint() {
    local token=$1
    local url=$2
    local method=${3:-GET}
    local expected=$4
    
    echo -n "  Testing $method $url ... "
    
    if [ -z "$token" ]; then
        response=$(curl -s -w "\n%{http_code}" -X $method "$url")
    else
        response=$(curl -s -w "\n%{http_code}" -X $method -H "Authorization: Bearer $token" "$url")
    fi
    
    http_code=$(echo "$response" | tail -n 1)
    body=$(echo "$response" | sed '$d')
    
    if [ "$http_code" == "$expected" ]; then
        echo "‚úÖ $http_code"
    else
        echo "‚ùå Expected $expected, got $http_code"
        echo "   Response: $body"
    fi
}

case ${1:-admin} in
    admin)
        echo "üß™ Testing ADMIN user (alice)"
        echo "Getting token..."
        ADMIN_TOKEN=$(get_token "alice" "password")
        echo "$ADMIN_TOKEN"
        
        if [ -z "$ADMIN_TOKEN" ] || [ "$ADMIN_TOKEN" == "null" ]; then
            echo "‚ùå Failed to get admin token. Run 'make setup-keycloak' first."
            exit 1
        fi
        
        echo ""
        echo "üìã Go Service:"
        test_endpoint "$ADMIN_TOKEN" "$GO_SERVICE/" "GET" "200"
        # test_endpoint "$ADMIN_TOKEN" "$GO_SERVICE/api/data" "GET" "200"
        # test_endpoint "$ADMIN_TOKEN" "$GO_SERVICE/admin/users" "GET" "200"
        # test_endpoint "$ADMIN_TOKEN" "$GO_SERVICE/api/data" "POST" "200"
        
        # echo ""
        # echo "üìã Python Service:"
        # test_endpoint "$ADMIN_TOKEN" "$PYTHON_SERVICE/" "GET" "200"
        # test_endpoint "$ADMIN_TOKEN" "$PYTHON_SERVICE/api/data" "GET" "200"
        # test_endpoint "$ADMIN_TOKEN" "$PYTHON_SERVICE/admin/users" "GET" "200"
        
        # echo ""
        # echo "üìã C# Service:"
        # test_endpoint "$ADMIN_TOKEN" "$CSHARP_SERVICE/" "GET" "200"
        # test_endpoint "$ADMIN_TOKEN" "$CSHARP_SERVICE/api/data" "GET" "200"
        # test_endpoint "$ADMIN_TOKEN" "$CSHARP_SERVICE/admin/users" "GET" "200"
        ;;
        
    user)
        echo "üß™ Testing REGULAR USER (bob)"
        echo "Getting token..."
        USER_TOKEN=$(get_token "bob" "password")
        
        if [ -z "$USER_TOKEN" ] || [ "$USER_TOKEN" == "null" ]; then
            echo "‚ùå Failed to get user token. Run 'make setup-keycloak' first."
            exit 1
        fi
        
        echo ""
        echo "üìã Should ALLOW (GET requests):"
        test_endpoint "$USER_TOKEN" "$GO_SERVICE/" "GET" "200"
        test_endpoint "$USER_TOKEN" "$GO_SERVICE/api/data" "GET" "200"
        
        echo ""
        echo "üìã Should DENY (POST/PUT/DELETE and admin endpoints):"
        test_endpoint "$USER_TOKEN" "$GO_SERVICE/api/data" "POST" "403"
        test_endpoint "$USER_TOKEN" "$GO_SERVICE/admin/users" "GET" "403"
        test_endpoint "$USER_TOKEN" "$PYTHON_SERVICE/admin/users" "GET" "403"
        ;;
        
    denied)
        echo "üß™ Testing ACCESS DENIAL scenarios"
        
        echo ""
        echo "üìã Should DENY (no token):"
        test_endpoint "" "$GO_SERVICE/" "GET" "401"
        test_endpoint "" "$PYTHON_SERVICE/api/data" "GET" "401"
        
        echo ""
        echo "üìã Should ALLOW (health endpoint without token):"
        test_endpoint "" "$GO_SERVICE/health" "GET" "200"
        test_endpoint "" "$PYTHON_SERVICE/health" "GET" "200"
        ;;
esac

echo ""
echo "‚úÖ Tests complete!"#!/bin/bash
set -e

KEYCLOAK_URL="http://localhost:8180"
ADMIN_USER="admin"
ADMIN_PASS="admin"
REALM="demo"

echo "Waiting for Keycloak to be ready..."
until curl -sf "$KEYCLOAK_URL/health/ready" > /dev/null; do
    sleep 2
done

echo "‚úÖ Keycloak is ready!"

# Get admin token
echo "Getting admin token..."
TOKEN=$(curl -s -X POST "$KEYCLOAK_URL/realms/master/protocol/openid-connect/token" \
  -d "client_id=admin-cli" \
  -d "username=$ADMIN_USER" \
  -d "password=$ADMIN_PASS" \
  -d "grant_type=password" | jq -r '.access_token')

if [ -z "$TOKEN" ] || [ "$TOKEN" == "null" ]; then
    echo "‚ùå Failed to get admin token"
    exit 1
fi

# Create demo realm
echo "Creating demo realm..."
curl -s -X POST "$KEYCLOAK_URL/admin/realms" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "realm": "'$REALM'",
    "enabled": true,
    "registrationAllowed": false,
    "loginWithEmailAllowed": true,
    "duplicateEmailsAllowed": false,
    "resetPasswordAllowed": true,
    "editUsernameAllowed": false,
    "bruteForceProtected": true
  }' || echo "Realm might already exist"

# Create a client with direct access grants enabled
echo "Creating demo-client..."
curl -s -X POST "$KEYCLOAK_URL/admin/realms/$REALM/clients" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "clientId": "demo-client",
    "name": "Demo Client",
    "description": "Client for direct access grants (password flow)",
    "enabled": true,
    "publicClient": true,
    "directAccessGrantsEnabled": true,
    "standardFlowEnabled": true,
    "implicitFlowEnabled": false,
    "serviceAccountsEnabled": false,
    "authorizationServicesEnabled": false,
    "redirectUris": ["*"],
    "webOrigins": ["*"],
    "protocol": "openid-connect"
  }' || echo "Client might already exist"

# Create roles
echo "Creating roles..."
for ROLE in admin user service; do
    curl -s -X POST "$KEYCLOAK_URL/admin/realms/$REALM/roles" \
      -H "Authorization: Bearer $TOKEN" \
      -H "Content-Type: application/json" \
      -d "{\"name\": \"$ROLE\", \"description\": \"$ROLE role\"}" || echo "Role $ROLE might already exist"
done

# Create admin user (alice)
echo "Creating admin user (alice)..."
curl -s -X POST "$KEYCLOAK_URL/admin/realms/$REALM/users" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "username": "alice",
    "email": "alice@example.com",
    "enabled": true,
    "emailVerified": true,
    "credentials": [{
      "type": "password",
      "value": "password",
      "temporary": false
    }]
  }' || echo "User alice might already exist"

# Get Alice's ID and assign admin role
echo "Assigning admin role to alice..."
ALICE_ID=$(curl -s "$KEYCLOAK_URL/admin/realms/$REALM/users?username=alice" \
    -H "Authorization: Bearer $TOKEN" | jq -r '.[0].id')

if [ ! -z "$ALICE_ID" ] && [ "$ALICE_ID" != "null" ]; then
    ADMIN_ROLE=$(curl -s "$KEYCLOAK_URL/admin/realms/$REALM/roles/admin" \
        -H "Authorization: Bearer $TOKEN")
    
    curl -s -X POST "$KEYCLOAK_URL/admin/realms/$REALM/users/$ALICE_ID/role-mappings/realm" \
        -H "Authorization: Bearer $TOKEN" \
        -H "Content-Type: application/json" \
        -d "[$ADMIN_ROLE]"
fi

# Create regular user (bob)
echo "Creating regular user (bob)..."
curl -s -X POST "$KEYCLOAK_URL/admin/realms/$REALM/users" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "username": "bob",
    "email": "bob@example.com",
    "enabled": true,
    "emailVerified": true,
    "credentials": [{
      "type": "password",
      "value": "password",
      "temporary": false
    }]
  }' || echo "User bob might already exist"

# Get Bob's ID and assign user role
echo "Assigning user role to bob..."
BOB_ID=$(curl -s "$KEYCLOAK_URL/admin/realms/$REALM/users?username=bob" \
    -H "Authorization: Bearer $TOKEN" | jq -r '.[0].id')

if [ ! -z "$BOB_ID" ] && [ "$BOB_ID" != "null" ]; then
    USER_ROLE=$(curl -s "$KEYCLOAK_URL/admin/realms/$REALM/roles/user" \
        -H "Authorization: Bearer $TOKEN")
    
    curl -s -X POST "$KEYCLOAK_URL/admin/realms/$REALM/users/$BOB_ID/role-mappings/realm" \
        -H "Authorization: Bearer $TOKEN" \
        -H "Content-Type: application/json" \
        -d "[$USER_ROLE]"
fi

echo ""
echo "‚úÖ Keycloak configuration complete!"
echo ""
echo "üìã Configuration:"
echo "  Realm: $REALM"
echo "  Client ID: demo-client (with direct access grants enabled)"
echo ""
echo "üë• Users created:"
echo "  Admin user: alice / password (role: admin)"
echo "  Regular user: bob / password (role: user)"
echo ""
echo "üß™ Test getting tokens:"
echo '  Admin:  curl -s -X POST http://localhost:8180/realms/demo/protocol/openid-connect/token -d "client_id=demo-client" -d "username=alice" -d "password=password" -d "grant_type=password" | jq -r ".access_token"'
echo '  User:   curl -s -X POST http://localhost:8180/realms/demo/protocol/openid-connect/token -d "client_id=demo-client" -d "username=bob" -d "password=password" -d "grant_type=password" | jq -r ".access_token"'
echo ""
echo "üîó Keycloak Admin Console: http://localhost:8180/admin (admin/admin)"package envoy.authz

import input.attributes.request.http as http_request
import input.attributes.metadata_context.filter_metadata["envoy.filters.http.jwt_authn"] as jwt_metadata

default allow = false

# Extract JWT claims
jwt_payload := payload {
    payload := jwt_metadata["jwt_payload"]
}

# Admin role can access everything
allow {
    jwt_payload.realm_access.roles[_] == "admin"
}

# User role can only GET
allow {
    jwt_payload.realm_access.roles[_] == "user"
    http_request.method == "GET"
}

# Service accounts can call /api/* endpoints
allow {
    jwt_payload.resource_access.account.roles[_] == "service"
    startswith(http_request.path, "/api/")
}

# Health endpoints are always accessible (no JWT required for monitoring)
allow {
    http_request.path == "/health"
}

# Debug: Log the decision
decision := {"allow": allow, "user": jwt_payload.preferred_username, "roles": jwt_payload.realm_access.roles}
{
  "attributes": {
    "request": {
      "http": {
        "method": "GET",
        "path": "/api/data",
        "headers": {
          "authorization": "Bearer eyJhbGc...",
          "host": "localhost:9001",
          "user-agent": "curl/7.68.0"
        }
      }
    },
    "metadata_context": {
      "filter_metadata": {
        "envoy.filters.http.jwt_authn": {
          "jwt_payload": {
            "sub": "f3b9c8d1-4e5a-6b7c-8d9e-0f1a2b3c4d5e",
            "preferred_username": "alice",
            "email": "alice@example.com",
            "realm_access": {
              "roles": ["admin", "user"]
            },
            "resource_access": {
              "account": {
                "roles": ["manage-account", "view-profile"]
              }
            },
            "iss": "http://keycloak:8180/realms/demo",
            "aud": "account",
            "exp": 1701964800,
            "iat": 1701961200
          }
        }
      }
    }
  }
}
version: '3.8'

services:
  # ============================================================================
  # Identity Provider (Keycloak)
  # ============================================================================
  keycloak:
    image: quay.io/keycloak/keycloak:23.0.4
    container_name: keycloak
    environment:
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: admin
      KC_HTTP_PORT: 8080
      KC_HOSTNAME: localhost
      KC_HOSTNAME_PORT: 8180
      KC_HOSTNAME_STRICT: false
    command: start-dev --health-enabled=true
    ports:
      - "8180:8080"
    networks:
      - zta-network

  # ============================================================================
  # Policy Engine (OPA)
  # ============================================================================
  opa:
    image: openpolicyagent/opa:0.60.0-envoy
    container_name: opa
    command:
      - "run"
      - "--server"
      - "--log-level=debug"
      - "--set=plugins.envoy_ext_authz_grpc.addr=:9191"
      - "--set=plugins.envoy_ext_authz_grpc.path=envoy/authz/allow"
      - "--set=decision_logs.console=true"
      - "/policies"
    volumes:
      - ./opa/policies:/policies:ro
    ports:
      - "8181:8181"
      - "9191:9191"
    networks:
      - zta-network

  # ============================================================================
  # Service 1: Go Service (with Envoy sidecar)
  # ============================================================================
  go-service:
    build:
      context: ./services/go-service
      dockerfile: Dockerfile
    container_name: go-service
    environment:
      SERVICE_NAME: go-service
      SERVICE_PORT: 8080
    networks:
      - zta-network
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:8080/health"]
      interval: 5s
      timeout: 3s
      retries: 3

  go-service-envoy:
    image: envoyproxy/envoy:v1.29.1
    container_name: go-service-envoy
    volumes:
      - ./envoy/go-service-envoy.yaml:/etc/envoy/envoy.yaml:ro
    ports:
      - "9001:8000"  # External port
    networks:
      - zta-network
    depends_on:
      - go-service
      - opa
      - keycloak

  # ============================================================================
  # Service 2: Python Service (with Envoy sidecar)
  # ============================================================================
  python-service:
    build:
      context: ./services/python-service
      dockerfile: Dockerfile
    container_name: python-service
    environment:
      SERVICE_NAME: python-service
      SERVICE_PORT: 8080
    networks:
      - zta-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 5s
      timeout: 3s
      retries: 3

  python-service-envoy:
    image: envoyproxy/envoy:v1.29.1
    container_name: python-service-envoy
    volumes:
      - ./envoy/python-service-envoy.yaml:/etc/envoy/envoy.yaml:ro
    ports:
      - "9002:8000"
    networks:
      - zta-network
    depends_on:
      - python-service
      - opa
      - keycloak

  # ============================================================================
  # Service 3: C# Service (with Envoy sidecar)
  # ============================================================================
  csharp-service:
    build:
      context: ./services/csharp-service
      dockerfile: Dockerfile
    container_name: csharp-service
    environment:
      SERVICE_NAME: csharp-service
      ASPNETCORE_URLS: http://+:8080
    networks:
      - zta-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 5s
      timeout: 3s
      retries: 3

  csharp-service-envoy:
    image: envoyproxy/envoy:v1.29.1
    container_name: csharp-service-envoy
    volumes:
      - ./envoy/csharp-service-envoy.yaml:/etc/envoy/envoy.yaml:ro
    ports:
      - "9003:8000"
    networks:
      - zta-network
    depends_on:
      - csharp-service
      - opa
      - keycloak

networks:
  zta-network:
    driver: bridge
fastapi==0.109.0
uvicorn[standard]==0.27.0
FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY main.py .
EXPOSE 8080
CMD ["python", "main.py"]
from fastapi import FastAPI, Request
from datetime import datetime
import os
import uvicorn

app = FastAPI()

SERVICE_NAME = os.getenv("SERVICE_NAME", "python-service")

@app.get("/")
async def root(request: Request):
    return {
        "service": SERVICE_NAME,
        "message": "Hello from Python service! This is a public endpoint.",
        "timestamp": datetime.now().isoformat(),
        "user": get_user(request)
    }

@app.get("/health")
async def health():
    return {"status": "healthy"}

@app.get("/api/data")
async def api_data(request: Request):
    return {
        "service": SERVICE_NAME,
        "message": "API data endpoint - requires user or admin role",
        "timestamp": datetime.now().isoformat(),
        "user": get_user(request)
    }

@app.get("/admin/users")
async def admin_users(request: Request):
    return {
        "service": SERVICE_NAME,
        "message": "Admin endpoint - requires admin role",
        "timestamp": datetime.now().isoformat(),
        "user": get_user(request)
    }

def get_user(request: Request):
    auth = request.headers.get("authorization", "")
    return "authenticated-user" if auth else "anonymous"

if __name__ == "__main__":
    port = int(os.getenv("SERVICE_PORT", "8080"))
    uvicorn.run(app, host="0.0.0.0", port=port)
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
COPY *.csproj .
RUN dotnet restore
COPY . .
RUN dotnet publish -c Release -o /app

FROM mcr.microsoft.com/dotnet/aspnet:8.0
WORKDIR /app
COPY --from=build /app .
EXPOSE 8080
ENTRYPOINT ["dotnet", "csharp-service.dll"]
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <RootNamespace>csharp_service</RootNamespace>
  </PropertyGroup>
</Project>
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Text.Json;

var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

var serviceName = Environment.GetEnvironmentVariable("SERVICE_NAME") ?? "csharp-service";

app.MapGet("/", (HttpContext context) =>
{
    return Results.Json(new
    {
        service = serviceName,
        message = "Hello from C# service! This is a public endpoint.",
        timestamp = DateTime.UtcNow,
        user = GetUser(context)
    });
});

app.MapGet("/health", () => Results.Json(new { status = "healthy" }));

app.MapGet("/api/data", (HttpContext context) =>
{
    return Results.Json(new
    {
        service = serviceName,
        message = "API data endpoint - requires user or admin role",
        timestamp = DateTime.UtcNow,
        user = GetUser(context)
    });
});

app.MapGet("/admin/users", (HttpContext context) =>
{
    return Results.Json(new
    {
        service = serviceName,
        message = "Admin endpoint - requires admin role",
        timestamp = DateTime.UtcNow,
        user = GetUser(context)
    });
});

string GetUser(HttpContext context)
{
    var auth = context.Request.Headers["Authorization"].ToString();
    return string.IsNullOrEmpty(auth) ? "anonymous" : "authenticated-user";
}

app.Run();
FROM golang:1.21-alpine AS builder
WORKDIR /app
COPY main.go .
RUN go mod init go-service && \
    go build -o service main.go

FROM alpine:latest
RUN apk --no-cache add ca-certificates wget
WORKDIR /root/
COPY --from=builder /app/service .
EXPOSE 8080
CMD ["./service"]
package main

import (
	"encoding/json"
	"log"
	"net/http"
	"os"
	"time"
)

type Response struct {
	Service   string    `json:"service"`
	Message   string    `json:"message"`
	Timestamp time.Time `json:"timestamp"`
	User      string    `json:"user,omitempty"`
}

func main() {
	serviceName := getEnv("SERVICE_NAME", "go-service")
	servicePort := getEnv("SERVICE_PORT", "8080")

	http.HandleFunc("/", handleRoot)
	http.HandleFunc("/health", handleHealth)
	http.HandleFunc("/api/data", handleAPIData)
	http.HandleFunc("/admin/users", handleAdminUsers)

	addr := ":" + servicePort
	log.Printf("%s starting on %s", serviceName, addr)
	if err := http.ListenAndServe(addr, nil); err != nil {
		log.Fatal(err)
	}
}

func handleRoot(w http.ResponseWriter, r *http.Request) {
	respond(w, Response{
		Service:   getEnv("SERVICE_NAME", "go-service"),
		Message:   "Hello from Go service! This is a public endpoint.",
		Timestamp: time.Now(),
		User:      getUser(r),
	})
}

func handleHealth(w http.ResponseWriter, r *http.Request) {
	respond(w, map[string]string{"status": "healthy"})
}

func handleAPIData(w http.ResponseWriter, r *http.Request) {
	respond(w, Response{
		Service:   getEnv("SERVICE_NAME", "go-service"),
		Message:   "API data endpoint - requires user or admin role",
		Timestamp: time.Now(),
		User:      getUser(r),
	})
}

func handleAdminUsers(w http.ResponseWriter, r *http.Request) {
	respond(w, Response{
		Service:   getEnv("SERVICE_NAME", "go-service"),
		Message:   "Admin endpoint - requires admin role",
		Timestamp: time.Now(),
		User:      getUser(r),
	})
}

func getUser(r *http.Request) string {
	// Envoy forwards JWT in header after validation
	auth := r.Header.Get("Authorization")
	if auth != "" {
		return "authenticated-user"
	}
	return "anonymous"
}

func respond(w http.ResponseWriter, data interface{}) {
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(data)
}

func getEnv(key, fallback string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return fallback
}
